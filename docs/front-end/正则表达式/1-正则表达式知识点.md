# 正则表达式知识点

## 1.匹配字符

### 模糊匹配

模糊匹配分为两种：横向模糊匹配和纵向模糊匹配。

#### 横向模糊匹配

横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。

```js
var regex = /ab{2,5}c/g;
```

例如上面的 `{2,5}` ，表示连续出现最少 `m` 次，最多 `n` 次。

#### 纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。

```js
var regex = /a[123]b/g;
```

例如上面的 `[123]` ，表示 `a` 和 `b` 中间的字符可以字符 `1` 、`2` 、`3` 中的任何一个。

### 字符组

#### 范围表示和排除字符组

- 范围表示：用连字符 `-` 来省略和简写：`[123456abcdefGHIJKLM]` 可以简写为 `[1-6a-fG-M]`；

- 排除字符组：在纵向模糊匹配中，某位字符可以是任何东西，但就不能是 `a` 、`b` 、`c` ，可以使用 `[^abc]` 表示，`^` 表示取反；

:::tip
匹配 `a` 、`-` 、`z` 中的任意一个字符，不能使用 `[a-z]` ，可以用 `[-az]` 或 `[az-]` 或 `[a\-z]`;
:::

#### 常见字符简写

| 简写 | 代表字符              | 含义                                                                 |
| ---- | --------------------- | -------------------------------------------------------------------- |
| `\d` | `[0-9]`               | 表示是一位数字                                                       |
| `\D` | `[^0-9]`              | 表示除数字外的任意字符                                               |
| `\w` | `[0-9a-zA-Z]`         | 表示数字、大小写字母和下划线，即单词字符                             |
| `\W` | `[^0-9a-zA-Z]`        | 表示非单词字符                                                       |
| `\s` | `[ \t\v\n\r\f]`       | 表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 |
| `\S` | `[^ \t\v\n\r\f]`      | 表示非空白符                                                         |
| `.`  | `[^\n\r\u2028\u2029]` | 通配符，表示几乎任意字符                                             |

:::tip
匹配任意字符：`[\d\D]` 或 `[\w\W]` 或 `[\s\S]` 或 `[^]`
:::

### 量词和惰性匹配

贪婪匹配和惰性匹配：正则表达式**默认是贪婪匹配**的，他会尽可能的多去匹配字符。

可以**通过在量词后面加个 `?` 代表惰性匹配**，他会尽可能的少去匹配，既满足最少条件即可。

| 简写   | 等价    | 含义                         | 惰性匹配 |
| ------ | ------- | ---------------------------- | -------- |
| `{m,}` |         | 表示至少出现 m 次            | `{m,}?`  |
| `{m}`  | `{m,m}` | 表示出现 m 次                | `{m,n}?` |
| `?`    | `{0,1}` | 表示出现或者不出现           | `??`     |
| `+`    | `{1,}`  | 表示出现至少一次             | `+?`     |
| `*`    | `{0,}`  | 表示出现任意次，有可能不出现 | `*?`     |

```js{2,3}
var string = "123 1234 12345 123456";
var regex1 = /\d{2,5}/g;
var regex2 = /\d{2,5}?/g;

console.log(string.match(regex1)); // ['123', '1234', '12345', '12345']
console.log(string.match(regex2)); //  ['12', '12', '34', '12', '34', '12', '34', '56']
```

### 多选分支

多选分支可以支持多个子模式任选其一；

具体形式如下：`(p1|p2|p3)`，其中 `p1`、`p2` 和 `p3` 是子模式，用 `|`（管道符）分隔，表示其中任何之一。

**多选分支是惰性的，只要匹配到了一个子模式，就不会再往后面匹配了。**

```js
var regex = /good|goodbye/g;
var string = "goodbye";
console.log(string.match(regex)); //  ["good"]
```

## 2.匹配位置

位置指的是相邻字符之间的位置；

| 简写    | 含义                                                                                                            |
| ------- | --------------------------------------------------------------------------------------------------------------- |
| `^`     | 匹配开头，在多行匹配中匹配行开头                                                                                |
| `$`     | 匹配结尾，在多行匹配中匹配行结尾                                                                                |
| `\b`    | `\b` 是单词边界，具体就是 `\w` 和 `\W` 之间的位置，也包括 `\w` 和 `^` 之间的位置，也包括 `\w` 和 `$` 之间的位置 |
| `\B`    | 非单词边界                                                                                                      |
| `(?=p)` | 正向先行断言。`p` 是一个子模式，即 `p` 前面的位置                                                               |
| `(?!p)` | 负向先行断言。就是 `(?=p)` 的反面意思，即不是 `p` 前面的位置                                                    |

#### `^` 和 `$`

```js
var result = "hello".replace(/^|$/g, "#");
console.log(result); // "#hello#"
```

#### `\b` 和 `\B`

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, "#");
console.log(result); // "[#JS#] #Lesson_01#.#mp4#"

var result = "[JS] Lesson_01.mp4".replace(/\B/g, "#");
console.log(result); // "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

#### `(?=p)` 和 `(?!p)`

```js
var result = "hello".replace(/(?=l)/g, "#");
console.log(result); // "he#l#lo"

var result = "hello".replace(/(?!l)/g, "#");
console.log(result); // "#h#ell#o#"
```

## 3.括号应用

### 分组和分支结构

```js
var regex = /(ab)+/g;
```

```js
var regex = /^I love (Apple|Banana)$/;
```

### 捕获型分组

能够捕获匹配到的数据，以便后续引用，成为捕获型分组。

#### 引用分组

提取和替换

#### 反向引用

在正则本身里引用分组，只能引用之前出现的分组，即反向引用。

```js
// 实现：
// 2016-06-12
// 2016/06/12
// 2016.06.12

var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
```

:::tip
`\1` 代表引用前面存在的第 1 个分组，`\2` 、 `\3` 以此类推。

如果引用不存在的分组时，正则不会报错，会匹配反向引用的字符本身。
:::

### 非捕获分组 `(?:p)`

如果只想要括号最原始的功能，不去引用它，可以使用非捕获分组 `(?:p)`;

```js
var regex = /(?:ab)+/g;
var string = "ababa abbb ababab";
console.log(string.match(regex)); // ["abab", "ab", "ababab"]
```

## 4.正则回溯

回溯法也称试探法。它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。

本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。

## 5.正则相关 API

**流程：匹配 - 验证 - 切分 - 提取 - 替换**

### String.prototype.search( `regexp` )

- 作用：`search()` 方法执行正则表达式和 `String` 对象之间的一个搜索匹配。

- 返回值：如果匹配成功，则 `search()` 返回正则表达式在字符串中首次匹配项的索引;否则，返回 -1。

```js
var str = "hey JudE";
var re = /[A-Z]/g;
var re2 = /[.]/g;
console.log(str.search(re)); //  4, which is the index of the first capital letter "J"
console.log(str.search(re2)); //  -1 cannot find '.' dot punctuation
```

### String.prototype.split( `separator` , `?limit` )

- 作用：`split()` 方法接受一个模式，通过搜索模式将字符串分割成一个有序的子串列表，将这些子串放入一个数组，并返回该数组。

### String.prototype.match( `regexp` )

- 作用：`match()` 方法检索返回一个字符串匹配正则表达式的结果。

- 返回值：如果使用 `g` 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。
  如果未使用 `g` 标志，则仅返回第一个完整匹配及其相关的捕获组（ `Array` ）。

:::tip
未使用 `g` 标志，返回的项目将具有如下所述的其他属性：

- groups: 一个命名捕获组对象，其键是捕获组名称，值是捕获组，如果未定义命名捕获组，则为 undefined。

- index: 匹配的结果的开始位置

- input: 搜索的字符串。
  :::

  ```js
  var str = "For more information, see Chapter 3.4.5.1";
  var re = /see (chapter \d+(\.\d)*)/i;
  var found = str.match(re);
  console.log(found);

  //  [ 'see Chapter 3.4.5.1',
  //    'Chapter 3.4.5.1',
  //    '.1',
  //    index: 22,
  //    input: 'For more information, see Chapter 3.4.5.1'
  //  ]

  // 'see Chapter 3.4.5.1' 是整个匹配。
  // 'Chapter 3.4.5.1' 被'(chapter \d+(\.\d)*)'捕获。
  // '.1' 是被'(\.\d)'捕获的最后一个值。
  // 'index' 属性 (22) 是整个匹配从零开始的索引。
  // 'input' 属性是被解析的原始字符串。
  ```

### String.prototype.replace( `regexp` | `substr` , `newSubStr` | `function` )

- 作用：`replace()` 方法返回一个由替换值（`replacement`）替换部分或所有的模式（`pattern`）匹配项后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。如果 `pattern` 是字符串，则仅替换第一个匹配项。

- 返回值：一个部分或全部匹配由替代模式所取代的新的字符串。

```js
var str = "Twas the night before Xmas...";
var newstr = str.replace(/xmas/i, "Christmas");
console.log(newstr); // Twas the night before Christmas...
```

### RegExp.prototype.test( `str` )

- 作用：`test()` 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。

- 返回值：返回 `true` 或 `false`。

:::tip
如果正则表达式设置了全局标志 `g` ，`test()` 的执行会改变正则表达式 `lastIndex` 属性。连续的执行 `test()` 方法，后续的执行将会从 `lastIndex` 处开始匹配字符串，( `exec()` 同样改变正则本身的 `lastIndex` 属性值).
:::

```js
let str = "hello world!";
let result = /^hello/.test(str);
console.log(result); // true
```

### RegExp.prototype.exec( `str` )

- 作用：`exec()` 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 `null` 。

- 返回值：如果匹配失败，`exec()` 方法返回 `null` ，并将正则表达式的 `lastIndex` 重置为 `0` 。如果匹配成功，`exec()` 方法返回一个数组，并更新正则表达式对象的 `lastIndex` 属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应一个匹配的捕获组。

:::tip
匹配成功，数组还具有以下额外的属性：

- index：匹配到的字符位于原始字符串的基于 `0` 的索引值。

- input：匹配的原始字符串。

- groups：一个命名捕获组对象，其键是名称，值是捕获组。若没有定义命名捕获组，则 `groups` 的值为 `undefined` 。参阅捕获组以了解更多信息。

- indices 此属性仅在设置了 `d` 标志位时存在。它是一个数组，其中每一个元素表示一个子字符串的边界。每个子字符串匹配本身就是一个数组，其中第一个元素表示起始索引，第二个元素表示结束索引。
  :::

  ```js
  const regex1 = RegExp("foo*", "g");
  const str1 = "table football, foosball";
  let array1;
  while ((array1 = regex1.exec(str1)) !== null) {
    console.log(`Found ${array1[0]}. Next starts at ${regex1.lastIndex}.`);
    // "Found foo. Next starts at 9."
    // "Found foo. Next starts at 19."
  }
  ```

## 参考

[JS 正则表达式完整教程（略长）](https://juejin.cn/post/6844903487155732494)
