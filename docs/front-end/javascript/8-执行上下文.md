# 执行上下文

## 执行上下文栈

执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。`JavaScript` 中的运行环境大概包括三种情况。

- 全局环境：`JavaScript` 代码运行起来会首先进入该环境；
- 函数环境：当函数被调用执行时，会进入当前函数中执行代码；
- eval

代码执行过程中遇到以上三种情况都会生成一个执行上下文。在一个 JavaScript 程序中，肯定会产生很多的执行上下文。

JavaScript 引擎会以堆栈的方式来处理它们。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。栈顶的上下文处理完毕后会自动出栈，全局上下文会在浏览器窗口关闭后出栈。

## 执行上下文特点

- 单线程
- 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
- 全局执行上下文只有一个，它在浏览器关闭时出栈
- 函数的执行上下文个数没有限制
- 每次调用一个函数都会创建新的执行上下文，即使调用的是自身函数

## 执行上下文的生命周期

### 执行上下文创建阶段

- 创建变量对象 VO`（Variable Object）`；
- 建立作用域链；
- 确定 `this` 指向；

### 执行上下文执行阶段

- 完成变量赋值；
- 函数引用；
- 执行其他代码；
- 执行完毕之后出栈，等待垃圾回收；

## 变量对象 VO

变量对象存储了在上下文中定义的变量和函数声明。

### 变量对象创建过程

- 创建 `arguments` 对象

  - 函数的所有形参由名称和对应值组成的一个变量对象的属性被创建；
  - 没有实参，属性值设为 undefined；

- 检查 `function` 函数声明创建属性，即 `function` 声明的函数

  - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；
  - 如果变量对象已经存在相同名称的属性，则完全替换这个属性（同名后面的覆盖前面的）；

- 检查 `var` 变量声明创建属性

  - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
  - 如果变量名称跟已经声明的形式参数或函数相同不做覆盖操作；

:::tip
可以看出函数声明优先级比变量声明高
:::

### 活动对象 AO

活动对象是在函数执行上下文里面的，其实也是变量对象，只是它需要在函数被调用时才被激活。

### 变量对象总结

1. 全局上下文的变量对象初始化是全局对象；
2. 函数上下文的变量对象初始化只包括 `arguments` 对象；
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值；
4. 在代码执行阶段，会再次修改变量对象的属性值；

未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。

## 作用域

作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

JavaScript 采用**词法作用域(lexical scoping)**，也就是静态作用域。

### 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样**由多个执行上下文的变量对象构成的链表就叫做作用域链。**

### 函数执行上下文中作用域链和变量对象的创建过程

函数的作用域在函数定义的时候就决定了。因为函数有一个内部属性 **`[[scope]]`**，当函数创建的时候，就会保存所有父变量对象到其中。

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。

```js
var scope = "global scope";
function checkscope() {
  var scope2 = "local scope";
  return scope2;
}
checkscope();
```

（1）checkscope 函数被创建，保存作用域链到 内部属性[[scope]]

```js
checkscope.[[scope]] = [
    globalContext.VO
];
```

（2）执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```js
ECStack = [checkscopeContext, globalContext];
```

（3）checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

```js
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
```

（4）第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
```

（5）第三步：将活动对象压入 checkscope 作用域链顶端

```js
checkscopeContext = {
  AO: {
    arguments: {
      length: 0,
    },
    scope2: undefined,
  },
  Scope: [AO, [[Scope]]],
};
```

（6）准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值

```js
checkscopeContext = {
  AO: {
    arguments: {
      length: 0,
    },
    scope2: "local scope",
  },
  Scope: [AO, [[Scope]]],
};
```

（7）查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出

```js
ECStack = [globalContext];
```
