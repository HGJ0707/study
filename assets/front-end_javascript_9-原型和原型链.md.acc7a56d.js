import{_ as o,o as t,c as e,U as c}from"./chunks/framework.fd3d4570.js";const r="/study/images/javascript/9-1-原型和原型链.png",f=JSON.parse('{"title":"原型和原型链","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/javascript/9-原型和原型链.md","filePath":"front-end/javascript/9-原型和原型链.md","lastUpdated":1690519571000}'),a={name:"front-end/javascript/9-原型和原型链.md"},_=c('<h1 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h1><p><img src="'+r+'" alt="img"></p><h2 id="proto" tabindex="-1"><code>__proto__</code> <a class="header-anchor" href="#proto" aria-label="Permalink to &quot;`__proto__`&quot;">​</a></h2><p><code>__proto__</code> 是每一个 JS 对象（除了 <code>null</code>）都有的一个属性，指向该对象的原型。</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会通过它的 <code>__proto__</code> 搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾( <code>null</code> );</p><p>通过 <code>__proto__</code> 属性将对象连接起来的这条链路就是原型链。</p><h2 id="prototype" tabindex="-1">prototype <a class="header-anchor" href="#prototype" aria-label="Permalink to &quot;prototype&quot;">​</a></h2><p><code>prototype</code> 是函数所独有的，指向函数的原型对象。</p><ul><li>作用：包含可以由特定类型的所有实例共享的属性和方法。也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</li><li>任何函数在创建的时候，其实会默认同时创建该函数的 <code>prototype</code> 对象。</li><li>因为函数的本质也是一个对象，所以也拥有 <code>__proto__</code> 和 <code>constructor</code> 属性。</li></ul><h2 id="constructor" tabindex="-1">constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;constructor&quot;">​</a></h2><p><code>constructor</code> 是对象才有，指向该对象的构造函数。</p><p>所有函数和对象最终都是由 <code>Function</code> 构造函数得来，所以 <code>constructor</code> 属性的终点就是 <code>Function</code> 这个函数；</p>',12),d=[_];function p(n,s,i,l,u,h){return t(),e("div",null,d)}const b=o(a,[["render",p]]);export{f as __pageData,b as default};
