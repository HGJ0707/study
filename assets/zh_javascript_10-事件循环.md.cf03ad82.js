import{_ as s,o as a,c as e,U as l}from"./chunks/framework.76fefcb6.js";const o="/study/images/javascript/10-1-eventLoop.jpg",m=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"zh/javascript/10-事件循环.md","filePath":"zh/javascript/10-事件循环.md"}'),n={name:"zh/javascript/10-事件循环.md"},p=l('<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h1><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>常见微任务</strong>：Promise.then()、MutationObserver、await、process.nextTick（Node.js）等；</p><p><strong>常见宏任务</strong>：script（整体代码）、setTimeout、setInterval、I/O 操作、UI 渲染、setImmediate（Node.js）等。</p></div><h2 id="浏览器中的事件循环" tabindex="-1">浏览器中的事件循环 <a class="header-anchor" href="#浏览器中的事件循环" aria-label="Permalink to &quot;浏览器中的事件循环&quot;">​</a></h2><p><img src="'+o+`" alt="img"></p><ol><li><p>首先执行执行栈中的代码，遇到异步任务则会放到任务队列中去；</p></li><li><p>执行栈中的任务都执行完后，查看任务队列中的异步任务是否到了执行的时机；</p></li><li><p>任务队列分为两种：微任务队列和宏任务队列。优先获取微任务队列中的任务放到执行栈中执行，再取宏任务进行执行；</p></li><li><p>任务队列取出来的任务放到执行栈中执行又会遇到异步任务，于是又回到第一步中，形成事件循环；</p></li></ol><h2 id="node-js-中的事件循环" tabindex="-1">Node.js 中的事件循环 <a class="header-anchor" href="#node-js-中的事件循环" aria-label="Permalink to &quot;Node.js 中的事件循环&quot;">​</a></h2><h2 id="node-事件循环模型" tabindex="-1">node 事件循环模型 <a class="header-anchor" href="#node-事件循环模型" aria-label="Permalink to &quot;node 事件循环模型&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">┌───────────────────────┐</span></span>
<span class="line"><span style="color:#A6ACCD;">┌─</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">│        timers         │</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └──────────┬────────────┘</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ┌──────────┴────────────┐</span></span>
<span class="line"><span style="color:#A6ACCD;">│  │     I</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">O callbacks     │</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └──────────┬────────────┘</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ┌──────────┴────────────┐</span></span>
<span class="line"><span style="color:#A6ACCD;">│  │     idle</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> prepare     │</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └──────────┬────────────┘      ┌───────────────┐</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ┌──────────┴────────────┐      │   </span><span style="color:#FFCB6B;">incoming</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">   │</span></span>
<span class="line"><span style="color:#A6ACCD;">│  │         poll          │</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">─────┤  connections</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> │</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └──────────┬────────────┘      │   data</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> etc</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ┌──────────┴────────────┐      └───────────────┘</span></span>
<span class="line"><span style="color:#A6ACCD;">│  │        check          │</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └──────────┬────────────┘</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ┌──────────┴────────────┐</span></span>
<span class="line"><span style="color:#A6ACCD;">└──┤    close callbacks    │</span></span>
<span class="line"><span style="color:#A6ACCD;">   └───────────────────────┘</span></span></code></pre></div><p>每个阶段都有一个<strong>FIFO</strong>的回调队列（queue）要执行。当 event loop 进入某个阶段后，会执行该阶段特定的（任意）操作，然后才会执行这个阶段的队列里的回调。当队列被执行完，或者执行的回调数量达到上限后，event loop 会进入下个阶段。</p><h3 id="事件循环各阶段描述" tabindex="-1">事件循环各阶段描述 <a class="header-anchor" href="#事件循环各阶段描述" aria-label="Permalink to &quot;事件循环各阶段描述&quot;">​</a></h3><ul><li><p><code>timers</code> 阶段: 这个阶段执行（ <code>setTimeout</code>、<code>setInterval</code> ）的回调，该阶段新创建的 <code>setTimeout</code>、<code>setInterval</code> 会继续放在下一个轮回循环阶段执行</p></li><li><p><code>I/O callbacks</code> 阶段: 执行一些系统操作的回调(比如网络通信的错误回调)；</p></li><li><p><code>idle, prepare</code> 阶段: 仅 node 内部使用;</p></li><li><p><code>poll</code> 阶段: 获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里（比如：文件读取操作，http 请求 回调） 底层代码在 <code>poll</code> 阶段执行的时候，会传入一个 timeout 超时时间，timeout 超时时间到了，则退出 <code>poll</code> 阶段，执行下一个阶段。</p></li><li><p><code>check</code> 阶段: 执行 <code>setImmediate()</code> 设定的 <code>callbacks</code>;</p></li><li><p><code>close callbacks</code> 阶段: 比如 <code>socket.on(‘close’, callback)</code>的 <code>callback</code> 会在这个阶段执行。</p></li></ul><h3 id="事件循环执行过程" tabindex="-1">事件循环执行过程 <a class="header-anchor" href="#事件循环执行过程" aria-label="Permalink to &quot;事件循环执行过程&quot;">​</a></h3><ul><li><p>node 的初始化，初始化 node 环境，执行输入代码</p></li><li><p>先执行同步任务、再执行 <code>process.nextTick</code> 、微任务；</p></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在事件循环的每一个子阶段退出之前都会执行：<code>process.nextTick</code>，微任务。（ <code>process.nextTick</code> 先于微任务执行）</p></div><ul><li><p>进入 event-loop</p></li><li><p>进入 timers 阶段（ <code>setTimeout</code>、<code>setInterval</code> ）</p></li><li><p>进入 IO callbacks 阶段</p></li><li><p>进入 idle，prepare 阶段</p></li><li><p>进入 poll 阶段</p></li><li><p>进入 check 阶段（ <code>setImmediate</code> ）</p></li><li><p>进入 closing 阶段</p></li><li><p>检查是否有活跃的 handles（定时器、IO 等事件句柄）。如果有，继续下一轮循环。如果没有，结束事件循环，退出程序。</p></li></ul><p><a href="https://blog.csdn.net/weixin_44730897/article/details/128135836" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_44730897/article/details/128135836</a></p>`,18),c=[p];function t(i,r,d,C,A,h){return a(),e("div",null,c)}const u=s(n,[["render",t]]);export{m as __pageData,u as default};
